/* P6EJ1.java */
/* Generated By:JavaCC: Do not edit this line. P6EJ1.java */
                     //unidad de compilación javacc
//Ejercicio 6 para entregar a la asignatura de Procesadores del lenguaje.
//Se ha intentado introducir una intrucción iterativa pero el resultado ha sido no satisfactorio
//Se ha añadido un tipo de bloque condicional además del original y el calculo de raices de polinomios

        import java.util.HashMap;
        import java.util.Map;
        import java.util.ArrayList;
        import java.util.Arrays;
        import java.util.concurrent.CountDownLatch;
        import java.util.concurrent.ExecutorService;
        import java.util.concurrent.Executors;
        import java.util.concurrent.Semaphore;
        import static java.lang.Math.pow;


        //ESTAS CLASES SON AUXILIARES Y SIRVEN PARA CALCULAR RAICES DE POLINOMIOS DE GRADO SUPERIOR A 4.

        //Esto es la clase responsable del calculo de raices, fue desarrollada en sistemas distribuidos basandome en lo que se vió en MAM, usa hilos para mejor eficiencia
        //Ha sido adaptada para esta calculadora y javacc, es original mía y me llevo cariño y esfuerzo desarrollarla, los conceptos estaban en MAM pero el código salió de mis dedos
        //Disfrutadla!
        //Esta se encarga de encontrar los parametros necesarios para localizar las raices y una vez las localiza las calcula con un metodo que converja a las mismas
        //este método está en la clase calculaRaiz y usa Newton-Raphson
        class CalcularRaices extends Thread{

                private ArrayList<Double> polinomio;

                public CalcularRaices(ArrayList<Double> polinomio) {
                        int cont = polinomio.size()-1;
                        for(int i = polinomio.size()-1; i >= 0; --i){
                                if(polinomio.get(i) != 0)
                                        break;
                                --cont;
                        }

                        ArrayList<Double> aux = new ArrayList<Double>();
                        for(int i = 0; i <= cont; ++i){
                                aux.add(polinomio.get(i));
                        }

                        this.polinomio = aux;

                }

                public void run() {
                        //En este hilo que será unico para cada polinomio, 1º con la regla de signos de Descartes
                        //tratar de ver más o menos cuantas raices positivas y negativas reales.
                        //2º acotación de las raices con MacLaurin
                        //3º (puramente educativo) buscamos posibles raíces enteras usando la regla de Horner.
                        //4º aplicamos sturm para obtener la secuencia del mismo {P(x),P1(x),...,Pn(x)} donde P es nuestro polinomio, P1 su derivada y 
                        //Pk(x) es el resto cambiado de signo de Pk-2(x)/Pk-1(x) para 2<=k<=n.
                        int NumCambiosDeSignoRNeg=0, NumCambiosDeSignoRPos=0;

                        //Aplicamos la regla de signos de Descartes
                        ArrayList<Double> Descartes = new ArrayList();
                        ArrayList<Double> DescartesNeg = new ArrayList();
                        for(int i=0; i<this.polinomio.size(); i++) {
                                if(this.polinomio.get(i)!=0) {
                                        Descartes.add(this.polinomio.get(i));
                                        if(i%2==0) {
                                                DescartesNeg.add(this.polinomio.get(i));
                                        }else
                                                DescartesNeg.add(this.polinomio.get(i)*-1);
                                }
                        }
                        for(int i=0;i<Descartes.size()-1;i++) {
                                if(Descartes.get(i)*Descartes.get(i+1)<0) {
                                        NumCambiosDeSignoRPos++;
                                }
                                if(DescartesNeg.get(i)*DescartesNeg.get(i+1)<0)
                                        NumCambiosDeSignoRNeg++;
                        }

                        //Ahora vamos a calcular las cotas con el Método de MacLaurin -> (1/(1+μ) < |ζi| < (1+λ) donde {ζ1,...,ζn} C Complejos las raices n raices. 
                        //Primero calculamos μ, con μ = máximo de {|ak/a0|} donde 1<=k<=n y a es el coeficiente de x.
                        double mu;
                        double cotaMinima;
                        if(this.polinomio.get(0)==0||this.polinomio.size()==1) {
                                mu=0;
                                cotaMinima=0;
                        }else {
                                mu=(this.polinomio.get(1)/this.polinomio.get(0));
                                for(int i=1;i<this.polinomio.size();++i) {
                                        if(mu<Math.abs(this.polinomio.get(i)/this.polinomio.get(0)))
                                                mu=Math.abs(this.polinomio.get(i)/this.polinomio.get(0));
                                }
                                cotaMinima = 1/(1+mu);
                        }

                        //Ahora calculamos λ, con λ = máximo de {|ak/an|} donde 0<=k<=n-1 y a es el coeficiente de x.
                        Double lambda=Math.abs((this.polinomio.get(0)/this.polinomio.get(this.polinomio.size()-1)));
                        for(int i=0;i<this.polinomio.size()-1;++i) {
                                if(lambda<Math.abs(this.polinomio.get(i)/this.polinomio.get(this.polinomio.size()-1)))
                                        lambda=Math.abs(this.polinomio.get(i)/this.polinomio.get(this.polinomio.size()-1));
                        }
                        Double cotaMaxima = 1+lambda;

                        //Usando la regla de Horner calculamos las posibles raices enteras, este paso es totalmente opcional, es solo puramente lúdico.
                        ArrayList<Double> PosiblesRaicesEnteras = new ArrayList();
                        Double a0 = this.polinomio.get(0);
                        for(int i=1;i<=a0;i++) {
                                if(a0%i==0) {
                                        PosiblesRaicesEnteras.add((double)i);
                                        PosiblesRaicesEnteras.add((double)-i);
                                }
                        }

                        //aplicamos sturm:

                        //Primero calculamos la derivada:
                        ArrayList<Double> p1 = this.Derivar(this.polinomio);

                        //Calculamos la secuencia:
                        ArrayList<ArrayList<Double>> listaDePolinomios = new ArrayList();
                        listaDePolinomios.add(this.polinomio);
                        listaDePolinomios.add(p1);
                        boolean RaicesSimples = SecuenciaSturm(p1,this.polinomio,listaDePolinomios,this.polinomio.size()-1,2);

                        //Teniendo la secuencia de sturm aplicamos el teorema sirviendonos del metodo de la bisección hasta encontrar 1 solo cambio de signo:
                        try{
                                if(Math.abs(TeoremaSturm(listaDePolinomios,cotaMaxima*-1)-TeoremaSturm(listaDePolinomios,cotaMaxima))==0) {
                                        if(this.polinomio.size()==1&&this.polinomio.get(0)==0) {
                                                System.out.println("La recta real son las ra\u00c3\u00adces de la funci\u00c3\u00b3n"+"\u005cr\u005cn");
                                        }else {
                                                System.out.println("No existen raices reales"+"\u005cr\u005cn");
                                        }
                                }else {
                                        int numeroRaices = Math.abs(TeoremaSturm(listaDePolinomios,cotaMaxima*-1)-TeoremaSturm(listaDePolinomios,cotaMaxima));
                                        ExecutorService pool = Executors.newFixedThreadPool(numeroRaices);
                                        Semaphore sem = new Semaphore(1);
                                        CountDownLatch count = new CountDownLatch(Math.abs(TeoremaSturm(listaDePolinomios,cotaMaxima*-1)-TeoremaSturm(listaDePolinomios,cotaMaxima)));
                                        LocalizarRaices(pool,listaDePolinomios,cotaMaxima*-1,cotaMaxima,sem,count);
                                        count.await();
                                }
                        } catch (InterruptedException e) {
                                e.printStackTrace();
                        }



                }

                public static ArrayList<Double> Derivar(ArrayList<Double> polinomio){
                        ArrayList<Double> derivada = new ArrayList();
                        for(int i=1; i<polinomio.size();i++) {
                                derivada.add(polinomio.get(i)*i);
                        }
                        return derivada;
                }

                public boolean SecuenciaSturm(ArrayList<Double> imenos2,ArrayList<Double> imenos1, ArrayList<ArrayList<Double>> listaDePolinomios, int grado, int numPaso){
                        if(numPaso<=grado) {
                                Double ultimoCoefi1 = imenos1.get(imenos1.size()-1);
                                int gradoDeCoefi1 = imenos1.size()-1;
                                Double ultimoCoefi2 = imenos2.get(imenos2.size()-1);
                                int gradoDeCoefi2 = imenos2.size()-1;
                                ArrayList<Double> aux = new ArrayList();
                                ArrayList<Double> copia = (ArrayList<Double>)imenos1.clone();
                                while(gradoDeCoefi2<=gradoDeCoefi1) {
                                        Double coeficoci = ultimoCoefi1/ultimoCoefi2;
                                        int gradococi = gradoDeCoefi1-gradoDeCoefi2;
                                        for(int i=0;i<gradoDeCoefi1;i++) {
                                                aux.add(i, null);
                                        }
                                        for(int i=0;i<=gradoDeCoefi2-1;i++) {
                                                Double resta = imenos2.get(i)*coeficoci;
                                                aux.set(i+gradococi,copia.get(i+gradococi)-resta);
                                        }
                                        for(int i=0;i<gradoDeCoefi1;i++) {
                                                if(aux.get(i)==null) {
                                                        aux.set(i, copia.get(i));
                                                }
                                        }
                                        int cont = aux.size()-1;
                                        while(cont>=0&&aux.get(cont)==0) {
                                                aux.remove(cont);
                                                cont--;
                                        }
                                        copia = (ArrayList<Double>)aux.clone();
                                        aux.clear();
                                        gradoDeCoefi1 = copia.size()-1;
                                        if(copia.size()==0) {
                                                gradoDeCoefi1=0;
                                        }else
                                                ultimoCoefi1 = copia.get(copia.size()-1);
                                }
                                if(copia.size()==0) {
                                        return false;
                                }
                                if(copia.size()==1) {
                                        if(copia.get(copia.size()-1)==0) {
                                                return false;
                                        }else {
                                                for(int i=0; i<copia.size();i++) {
                                                        copia.set(i,copia.get(i)*-1);
                                                }
                                                listaDePolinomios.add(copia);
                                                return true;
                                        }
                                }else {
                                        for(int i=0; i<copia.size();i++) {
                                                copia.set(i,copia.get(i)*-1);
                                        }
                                        listaDePolinomios.add(copia);
                                        return SecuenciaSturm(copia,imenos2,listaDePolinomios,grado,(numPaso+1));
                                }
                        }else {
                                return false;
                        }
                }

                public int TeoremaSturm(ArrayList<ArrayList<Double>> listaDePolinomios,Double x) {
                        ArrayList<String> signos = new ArrayList();
                        for(int i=0;i<listaDePolinomios.size();i++) {
                                double total=0;
                                for(int j=0;j<listaDePolinomios.get(i).size();j++) {
                                        total += listaDePolinomios.get(i).get(j)*Math.pow(x, j);
                                }
                                if(total<0) {
                                        signos.add("-");
                                }else {
                                        signos.add("+");
                                }
                        }
                        int cambios=0;
                        for(int i=0;i<signos.size();i++) {
                                if(i<signos.size()-1&&!(signos.get(i).equals(signos.get(i+1)))) {
                                        cambios++;
                                }
                        }
                        return cambios;
                }

                public void LocalizarRaices(ExecutorService pool,ArrayList<ArrayList<Double>> listaDePolinomios,Double cotaMaximaIz,Double cotaMaximaDer, Semaphore sem,CountDownLatch count) {
                        CalcularRaiz a;
                        CalcularRaiz b;
                        if(Math.abs(TeoremaSturm(listaDePolinomios,cotaMaximaIz)-TeoremaSturm(listaDePolinomios,cotaMaximaDer))==1) {
                                if(TeoremaSturm(listaDePolinomios,cotaMaximaIz)-TeoremaSturm(listaDePolinomios,(cotaMaximaDer+cotaMaximaIz)/2)==1) {
                                        a = new CalcularRaiz(this.polinomio,(cotaMaximaIz+(cotaMaximaDer+cotaMaximaIz)/2)/2,(Double)Math.pow(10, -15),sem,count);
                                        pool.execute(a);
                                }else {
                                        a = new CalcularRaiz(this.polinomio,(cotaMaximaDer+(cotaMaximaDer+cotaMaximaIz)/2)/2,(Double)Math.pow(10, -15),sem,count);
                                        pool.execute(a);
                                }
                        }else {
                                Double c = (cotaMaximaDer+cotaMaximaIz)/2;
                                if(Math.abs(TeoremaSturm(listaDePolinomios,cotaMaximaIz)-TeoremaSturm(listaDePolinomios,c))==1){
                                        a = new CalcularRaiz(this.polinomio,(cotaMaximaIz+c)/2,(Double)Math.pow(10, -15),sem,count);
                                        pool.execute(a);
                                }
                                if(Math.abs(TeoremaSturm(listaDePolinomios,c)-TeoremaSturm(listaDePolinomios,cotaMaximaDer))==1){
                                        b = new CalcularRaiz(this.polinomio,(cotaMaximaDer+c)/2,(Double)Math.pow(10, -15),sem,count);
                                        pool.execute(b);
                                }
                                if(Math.abs(TeoremaSturm(listaDePolinomios,cotaMaximaIz)-TeoremaSturm(listaDePolinomios,c))>1){
                                        LocalizarRaices(pool,listaDePolinomios,cotaMaximaIz,c,sem,count);
                                }
                                if(Math.abs(TeoremaSturm(listaDePolinomios,c)-TeoremaSturm(listaDePolinomios,cotaMaximaDer))>1) {
                                        LocalizarRaices(pool,listaDePolinomios,c,cotaMaximaDer,sem,count);
                                }
                        }
                }

        }

        //Este es el hilo que se encarga de calcular las raices de manera individual por Newton Raphson
        class CalcularRaiz extends Thread{

                private ArrayList<Double> polinomio;
                private double puntoInicio;
                private double error;
                private double resultado;
                private Semaphore sem;
                private CountDownLatch cl;

                public CalcularRaiz(ArrayList<Double> pol, double puntoInicio,double error,Semaphore sem,CountDownLatch cl) {
                        this.polinomio=pol;
                        this.puntoInicio=puntoInicio;
                        this.error=error;
                        this.sem=sem;
                        this.cl=cl;
                }


                public void run() {

                        //Aplicaremos el metodo iterativo de Newton-Raphson para calcular la raiz en cuestion:
                        double aproximacionAnterior=this.puntoInicio;
                        ArrayList<Double> derivada = CalcularRaices.Derivar(this.polinomio);
                        double evaDerivada = evaluacion(derivada,this.puntoInicio);
                        if(evaDerivada==0)
                                this.puntoInicio*=2;
                        double aproximacion = this.puntoInicio-evaluacion(polinomio,this.puntoInicio)/evaluacion(derivada,this.puntoInicio);
                        while(Math.abs(aproximacion-aproximacionAnterior)>error) {
                                aproximacionAnterior=aproximacion;
                                aproximacion = aproximacion - (evaluacion(polinomio,aproximacion)/evaluacion(derivada,aproximacion));
                        }
                        try {
                                this.resultado=aproximacionAnterior;
                                sem.acquire();
                                this.Escribir();
                                sem.release();
                                cl.countDown();

                        }catch(InterruptedException e) {
                                e.printStackTrace();
                        }

                }

                public double evaluacion(ArrayList<Double> polinomio, double x) {
                        double resultado=0;
                        for(int i=0;i<polinomio.size();i++) {
                                resultado+=polinomio.get(i)*Math.pow(x, i);
                        }
                        return resultado;
                }

                public double getResultado() {
                        return this.resultado;
                }

                public synchronized void Escribir() {
                        if(Math.abs(this.resultado)<Math.pow(10, -9)) {
                                System.out.println("Raiz: " + String.valueOf(resultado)+" Aprox: 0"+"\u005cr\u005cn");
                        }else
                                System.out.println("Raiz: " + String.valueOf(resultado)+"\u005cr\u005cn");
                }

        }

                class P6EJ1 implements P6EJ1Constants {

                public static Map<String,Integer> variables = new HashMap<String,Integer>();
                public static int ans;
                public static double[] polinomioG = new double[100];

                public static void main(String[] args) throws ParseException, TokenMgrError {

                  //llamada a uno de los constructores por defecto
                  P6EJ1 parser = new P6EJ1 (System.in);
                  //llamada al método del símbolo inicial
                  parser.inicio(); }

                public static boolean comparar(String comparador, int expresion1, int expresion2){

                        switch(comparador){

                                case "<":
                                        return (expresion1 < expresion2);
                                case ">":
                                        return (expresion1 > expresion2);
                                case "==":
                                        return (expresion1 == expresion2);
                                case ">=":
                                        return (expresion1 >= expresion2);
                                case "<=":
                                        return (expresion1 <= expresion2);
                                case "!=":
                                        return (expresion1 != expresion2);
                                default:
                                        return false;}
                        }

//Simbolo inicial, es el que llama a línea y muestra el resultado por pantalla
  static final public void inicio() throws ParseException {int resultado;
    label_1:
    while (true) {
      resultado = Linea();
System.out.println("Resultado: "+resultado);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DECIMAL:
      case BINARIO:
      case OCTAL:
      case IF:
      case RAIZ:
      case SOLVE:
      case ID:
      case ANS:
      case 25:
      case 28:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(0);
  }

//No terminal Linea para la gramática, llama o a Asignacion o a Expresion o a CalcularRaices o a ResolverPolinomio o a Condicional o (por último) a CondicionalExt
  static final public int Linea() throws ParseException {int resultado = 0;
    if (jj_2_1(2)) {
      resultado = Asignacion();
      jj_consume_token(EOL);
    } else if (jj_2_2(2)) {
      resultado = Expresion();
      jj_consume_token(EOL);
    } else if (jj_2_3(2)) {
      CalcularRaices();
      jj_consume_token(EOL);
    } else if (jj_2_4(2)) {
      resultado = ResolverPolinomio();
      jj_consume_token(EOL);
    } else if (jj_2_5(2)) {
      resultado = Condicional();
    } else if (jj_2_6(2)) {
      resultado = CondicionalExt();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
ans = resultado;
        {if ("" != null) return resultado;}
    throw new Error("Missing return statement in function");
  }

//Reconoce un toquen ID el igual y la expresión a asignar, coloca esa variable en la tabla de variables.
  static final public int Asignacion() throws ParseException {int resultado; Token t;
    t = jj_consume_token(ID);
    jj_consume_token(23);
    resultado = Expresion();
variables.put(t.image, resultado);

        {if ("" != null) return resultado;}
    throw new Error("Missing return statement in function");
  }

//No terminal Expresion de la gramática, reconoce un termino seguido por 0 o más simbolos "+" o "-" y terminos, luego calcula el valor de sumarlos o restarlos.
  static final public int Expresion() throws ParseException {int resultado, termino;
                                        String simbolo;
    resultado = Termino();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 24:
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 24:{
        simbolo = jj_consume_token(24).image;
        break;
        }
      case 25:{
        simbolo = jj_consume_token(25).image;
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      termino = Termino();
if(simbolo == "+"){
                        resultado += termino;
                }else{
                        resultado -= termino;
                        }
    }
{if ("" != null) return resultado;}
    throw new Error("Missing return statement in function");
  }

//No terminal Termino de la gramática, la idea es similar al del anterior, reconoce factor seguido de 0 o más simbolos "*" o "/" y terminos, calcula la operación y la devuelve.
  static final public int Termino() throws ParseException {int resultado, factor;
                                String simbolo;
    resultado = Factor();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 26:
      case 27:{
        ;
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 26:{
        simbolo = jj_consume_token(26).image;
        break;
        }
      case 27:{
        simbolo = jj_consume_token(27).image;
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      factor = Factor();
if(simbolo == "*"){
                        resultado *= factor;
                }else{
                        resultado /= factor;
                        }
    }
{if ("" != null) return resultado;}
    throw new Error("Missing return statement in function");
  }

//No terminal Factor de la gramática, espera opcionalmente un signo menos, un Numero o una expresion entre parentesis o una variable o el ANS.
  static final public int Factor() throws ParseException {int resultado; boolean signo = false;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 25:{
      jj_consume_token(25);
signo = true;
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DECIMAL:
    case BINARIO:
    case OCTAL:{
      resultado = Numero();
      break;
      }
    case 28:{
      jj_consume_token(28);
      resultado = Expresion();
      jj_consume_token(29);
      break;
      }
    case ID:{
      resultado = Variable();
      break;
      }
    case ANS:{
      jj_consume_token(ANS);
resultado = ans;
      break;
      }
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
if(signo)
                {if ("" != null) return -1*resultado;}
        else
                {if ("" != null) return resultado;}
    throw new Error("Missing return statement in function");
  }

//Devuelve el resultado de la imagen de la variable en la tabla de variables.
  static final public int Variable() throws ParseException {int resultado; Token t;
    t = jj_consume_token(ID);
resultado = variables.get(t.image);
{if ("" != null) return resultado;}
    throw new Error("Missing return statement in function");
  }

//No terminal que reconoce si es un numero octal, binario o decimal y en segun el caso cambia de base a 10.
  static final public int Numero() throws ParseException {Token t;
                                int resultado;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DECIMAL:{
      t = jj_consume_token(DECIMAL);
      break;
      }
    case OCTAL:{
      t = jj_consume_token(OCTAL);
      break;
      }
    case BINARIO:{
      t = jj_consume_token(BINARIO);
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
if(t.image.charAt(t.image.length()-1) == 'b'){
                        resultado = Integer.parseInt(t.image.substring(0, t.image.length()-1),2);
                        }
                else if(t.image.charAt(t.image.length()-1) == 'o'){
                        resultado = Integer.parseInt(t.image.substring(0, t.image.length()-1),8);
                        }
                else{
                        resultado = Integer.parseInt(t.image);
                        }
{if ("" != null) return resultado;}
    throw new Error("Missing return statement in function");
  }

//Este no terminal condicional extendido tiene una sintaxis muy similar al if de programacion pero en castellano y con alguna modificación
//Comienza con un token "si" un parentesis, una expresión el comparador otra expresión el parentesis que cierra la condición un token "entonces" la expresión a ejecutar en ese caso
//un token "si no si" y su condición similar al anterior entre paréntesis y la expresión a ejecutar en el caso de que se cumpliese ese else if y por ultimo el "si no" que es el else
//que contiene una expresión que se ejecutará en el caso de que ninguna otra condición se cumpla.
  static final public int CondicionalExt() throws ParseException {String comparador;
                                        int expresion1, expresion2, entonces = 0, sino, i=0;
                                        boolean condicion = false;
                                        boolean condiciones[] = new boolean[50];
                                        int entonceses[] = new int[50];
    jj_consume_token(IF);
    jj_consume_token(28);
    expresion1 = Expresion();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MENOR:{
      comparador = jj_consume_token(MENOR).image;
      break;
      }
    case MAYOR:{
      comparador = jj_consume_token(MAYOR).image;
      break;
      }
    case IGUAL:{
      comparador = jj_consume_token(IGUAL).image;
      break;
      }
    case MENOIG:{
      comparador = jj_consume_token(MENOIG).image;
      break;
      }
    case MAYOIG:{
      comparador = jj_consume_token(MAYOIG).image;
      break;
      }
    case DISTINTO:{
      comparador = jj_consume_token(DISTINTO).image;
      break;
      }
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    expresion2 = Expresion();
    jj_consume_token(29);
    jj_consume_token(THEN);
    entonceses[i] = Linea();
condiciones[i] = comparar(comparador, expresion1, expresion2);
                        ++i;
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ELIF:{
        ;
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        break label_4;
      }
      jj_consume_token(ELIF);
      jj_consume_token(28);
      expresion1 = Expresion();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MENOR:{
        comparador = jj_consume_token(MENOR).image;
        break;
        }
      case MAYOR:{
        comparador = jj_consume_token(MAYOR).image;
        break;
        }
      case IGUAL:{
        comparador = jj_consume_token(IGUAL).image;
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      expresion2 = Expresion();
      jj_consume_token(29);
      jj_consume_token(THEN);
      entonceses[i] = Linea();
condiciones[i] = comparar(comparador, expresion1, expresion2);
                        ++i;
    }
    jj_consume_token(ELSE);
    sino = Linea();
for(int j = 0; j < condiciones.length; ++j){
                        if (condiciones[j]){
                                condicion = true;
                                entonces = entonceses[j];
                                break;
                        }
                }
                if(condicion)
                        {if ("" != null) return entonces;}
                else
                        {if ("" != null) return sino;}
    throw new Error("Missing return statement in function");
  }

//Este condicional es tal cual el condicional que se pide en el ejercicio pero se añaden más modos de comparar "<=" ">=" "!="
  static final public int Condicional() throws ParseException {int expresion1, expresion2, entonces, sino;
                                   boolean comparacion;
                                   String comparador;
    jj_consume_token(28);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MENOR:{
      comparador = jj_consume_token(MENOR).image;
      break;
      }
    case MAYOR:{
      comparador = jj_consume_token(MAYOR).image;
      break;
      }
    case IGUAL:{
      comparador = jj_consume_token(IGUAL).image;
      break;
      }
    case MENOIG:{
      comparador = jj_consume_token(MENOIG).image;
      break;
      }
    case MAYOIG:{
      comparador = jj_consume_token(MAYOIG).image;
      break;
      }
    case DISTINTO:{
      comparador = jj_consume_token(DISTINTO).image;
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    expresion1 = Expresion();
    expresion2 = Expresion();
    jj_consume_token(29);
    entonces = Expresion();
    jj_consume_token(30);
    sino = Expresion();
comparacion = comparar(comparador, expresion1, expresion2);
                if(comparacion)
                        {if ("" != null) return entonces;}
                else
                        {if ("" != null) return sino;}
    throw new Error("Missing return statement in function");
  }

//Este no terminal es el responsable de calcular las raices del polinomio
//Llamando a la clase de arriba del fichero, comienza reconociendo el token "RT:"
  static final public void CalcularRaices() throws ParseException {
    jj_consume_token(RAIZ);
    jj_consume_token(30);
    Polinomio();
ArrayList<Double> lista = new ArrayList<Double>();
                        for( double item: polinomioG)
                                lista.add(item);

                        CalcularRaices a = new CalcularRaices(lista);
                        a.start();

                        polinomioG = new double[100];
  }

//Este no terminal recoge el polinomio llamando a Polinomio y evalua el valor introducido despues del polinomio en el mismo.
//Este no terminal comienza reconociendo el toquen "SV:"
  static final public int ResolverPolinomio() throws ParseException {int susti;
                                                 double resultado = 0;
    jj_consume_token(SOLVE);
    jj_consume_token(30);
    Polinomio();
    jj_consume_token(31);
    susti = Expresion();
ArrayList<Double> polinomio = new ArrayList<Double>();
                for( double item: polinomioG)
                        polinomio.add(item);

                int cont = polinomio.size()-1;
                for(int i = polinomio.size()-1; i >= 0; --i){
                        if(polinomio.get(i) != 0)
                                break;
                        --cont;
                }

                ArrayList<Double> aux = new ArrayList<Double>();

                for(int i = 0; i <= cont; ++i){
                        aux.add(polinomio.get(i));
                }

                for(int i=0; i<aux.size(); i++){
                  if(i == 0)
                        resultado += aux.get(0);
                  else
                        resultado += aux.get(i)*pow(susti,i);
                }

                polinomioG = new double[100];

                {if ("" != null) return (int) Math.round(resultado);}
    throw new Error("Missing return statement in function");
  }

//Un no terminal que es un monomio seguido de 0 o más monomios
  static final public void Polinomio() throws ParseException {
    Monomio();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 24:
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        break label_5;
      }
      Monomio();
    }
  }

//Reconoce un signo el coeficiente, la "x" el exponente, el exponente es opcional luego la x estará elevada a 1, la x y el exponente es opcional luego será el termino independiente
//Y el coeficiente es opcional luego será la x sola
  static final public void Monomio() throws ParseException {boolean signo = false, solox = true, termInd = true;
                                int coeficiente=1, exponente=0;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 24:{
      jj_consume_token(24);
      break;
      }
    case 25:{
      jj_consume_token(25);
signo = true;
      break;
      }
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DECIMAL:
    case BINARIO:
    case OCTAL:{
      coeficiente = Numero();
      break;
      }
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case X:{
      jj_consume_token(X);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DECIMAL:
      case BINARIO:
      case OCTAL:{
        exponente = Numero();
solox = false;
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        ;
      }
termInd = false;
      break;
      }
    default:
      jj_la1[16] = jj_gen;
      ;
    }
if(termInd){
                exponente = 0;
        }
        if(solox && !termInd){
                exponente = 1;
        }

        if(signo){
                coeficiente *= -1;
        }

        polinomioG[exponente] += Double.valueOf(coeficiente);
  }

  static private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  static private boolean jj_3_6()
 {
    if (jj_3R_11()) return true;
    return false;
  }

  static private boolean jj_3R_9()
 {
    if (jj_scan_token(SOLVE)) return true;
    if (jj_scan_token(30)) return true;
    return false;
  }

  static private boolean jj_3_5()
 {
    if (jj_3R_10()) return true;
    return false;
  }

  static private boolean jj_3_4()
 {
    if (jj_3R_9()) return true;
    return false;
  }

  static private boolean jj_3_3()
 {
    if (jj_3R_8()) return true;
    return false;
  }

  static private boolean jj_3_2()
 {
    if (jj_3R_7()) return true;
    if (jj_scan_token(EOL)) return true;
    return false;
  }

  static private boolean jj_3_1()
 {
    if (jj_3R_6()) return true;
    return false;
  }

  static private boolean jj_3R_13()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) return true;
    }
    return false;
  }

  static private boolean jj_3R_21()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(5)) {
    jj_scanpos = xsp;
    if (jj_scan_token(7)) {
    jj_scanpos = xsp;
    if (jj_scan_token(6)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_12()
 {
    if (jj_3R_14()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_15()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_17()
 {
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3R_8()
 {
    if (jj_scan_token(RAIZ)) return true;
    if (jj_scan_token(30)) return true;
    return false;
  }

  static private boolean jj_3R_22()
 {
    if (jj_scan_token(ID)) return true;
    return false;
  }

  static private boolean jj_3R_20()
 {
    if (jj_scan_token(ANS)) return true;
    return false;
  }

  static private boolean jj_3R_7()
 {
    if (jj_3R_12()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_13()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_11()
 {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(28)) return true;
    return false;
  }

  static private boolean jj_3R_10()
 {
    if (jj_scan_token(28)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(9)) {
    jj_scanpos = xsp;
    if (jj_scan_token(8)) {
    jj_scanpos = xsp;
    if (jj_scan_token(10)) {
    jj_scanpos = xsp;
    if (jj_scan_token(12)) {
    jj_scanpos = xsp;
    if (jj_scan_token(11)) {
    jj_scanpos = xsp;
    if (jj_scan_token(13)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_15()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(26)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) return true;
    }
    return false;
  }

  static private boolean jj_3R_16()
 {
    if (jj_scan_token(25)) return true;
    return false;
  }

  static private boolean jj_3R_14()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_16()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_17()) {
    jj_scanpos = xsp;
    if (jj_3R_18()) {
    jj_scanpos = xsp;
    if (jj_3R_19()) {
    jj_scanpos = xsp;
    if (jj_3R_20()) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_18()
 {
    if (jj_scan_token(28)) return true;
    if (jj_3R_7()) return true;
    return false;
  }

  static private boolean jj_3R_6()
 {
    if (jj_scan_token(ID)) return true;
    if (jj_scan_token(23)) return true;
    return false;
  }

  static private boolean jj_3R_19()
 {
    if (jj_3R_22()) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public P6EJ1TokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[17];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x127840e0,0x3000000,0x3000000,0xc000000,0xc000000,0x2000000,0x106000e0,0xe0,0x3f00,0x8000,0x700,0x3f00,0x3000000,0x3000000,0xe0,0xe0,0x40000,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[6];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public P6EJ1(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public P6EJ1(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new P6EJ1TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public P6EJ1(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new P6EJ1TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public P6EJ1(P6EJ1TokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(P6EJ1TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[32];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 17; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 32; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 6; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

                }
